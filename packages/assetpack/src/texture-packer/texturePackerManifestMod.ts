import fs from 'fs-extra';
import { findAssets, path } from '../core/index.js';
import { type PixiManifest, type PixiManifestOptions } from '../manifest/pixiManifest.js';
import { getFileSizeInKB } from '../manifest/utils.js';

import type { Asset, AssetPipe } from '../core/index.js';

export type TexturePackerManifestOptions = Pick<PixiManifestOptions, 'output' | 'includeFileSizes'>;

/**
 * This pipe will modify the manifest generated by 'pixiManifest'. It will replace the progressSize
 * of each src to ensure it includes the size of the texture and the json combined
 *
 * Once done, it rewrites the manifest.
 *
 * This should be added after the `pixiManifest` pipe.
 *
 * ensure that the same output path is passed to the pipe as the `pixiManifest` pipe. Otherwise
 * the manifest will not be found.
 *
 * As this pipe needs to know about all the textures in the texture files most of the work is done
 * in the finish method.
 *
 * Kind of like applying a patch at the end of the manifest process.
 *
 * @param _options
 * @returns
 */
export function texturePackerManifestMod(
    _options: TexturePackerManifestOptions = {},
): AssetPipe<TexturePackerManifestOptions> {
    const defaultOptions: TexturePackerManifestOptions = {
        output: 'manifest.json',
        includeFileSizes: false,
        ..._options,
    };

    return {
        folder: false,
        name: 'texture-packer-manifest',
        defaultOptions,

        async finish(asset: Asset, options, pipeSystem) {
            if (options.includeFileSizes === false) {
                return;
            }
            const spritesheets = findAssets(
                (asset) => asset.extension === '.json' && asset.allMetaData.tps && asset.transformChildren.length === 0,
                asset,
                true,
            );

            const manifestLocation = options.output;

            const newFileName =
                path.dirname(manifestLocation) === '.'
                    ? path.joinSafe(pipeSystem.outputPath, manifestLocation)
                    : manifestLocation;

            const manifest = fs.readJsonSync(newFileName);

            spritesheets.forEach((atlasAsset) => {
                const buffer = atlasAsset.buffer;
                const json = JSON.parse(buffer.toString());

                if (!json.meta || !json.meta.image) {
                    return;
                }

                const textures: string[] = Array.isArray(json.meta.image) ? json.meta.image : [json.meta.image];

                textures.forEach((texture) => {
                    let size = 0;
                    const manifestPath = path.relative(pipeSystem.outputPath, atlasAsset.path);
                    const texturePath = path.resolve(atlasAsset.directory, texture);

                    if (texturePath) {
                        size = getFileSizeInKB(texturePath, options.includeFileSizes === 'raw');
                    }
                    findAndAddManifestAsset(manifest, `${manifestPath}`, size);
                });
            });

            fs.writeJSONSync(newFileName, manifest, { spaces: 2 });
        },
    };
}

function findAndAddManifestAsset(manifest: PixiManifest, assetPath: string, totalSize: number) {
    for (let i = 0; i < manifest.bundles.length; i++) {
        const assets = manifest.bundles[i].assets;

        const manifestAsset = assets.find((asset) => {
            return asset.src.find((src) => (typeof src === 'string' ? src : src.src) === assetPath);
        });

        if (manifestAsset) {
            const src = manifestAsset.src.find((src) => (typeof src === 'string' ? src : src.src) === assetPath);

            if (typeof src === 'object') {
                src.progressSize = Number(((src.progressSize || 0) + totalSize).toFixed(2));
            } else {
                // convert to object
                const index = manifestAsset.src.indexOf(src!);

                manifestAsset.src[index] = {
                    src: src!,
                    progressSize: totalSize,
                };
            }
            break;
        }
    }
}
