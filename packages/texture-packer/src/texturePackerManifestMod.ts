import type { Asset } from '@play-co/assetpack-core';
import { type AssetPipe, path, findAssets } from '@play-co/assetpack-core';
import { existsSync, readJsonSync, writeJSONSync } from 'fs-extra';

export interface TexturePackerManifestOptions
{
    output?: string;
}

/**
 * This pipe will modify the manifest generated by 'pixiManifest'. It will remove the entry
 * in the manifest - which groups all the textures and jsons under one asset and replace it with
 * the assets representing individual pages of the sprite sheet.
 *
 * Once done, it rewrites the manifest.
 *
 * This should be added after the `pixiManifest` pipe.
 *
 * ensure that the same output path is passed to the pipe as the `pixiManifest` pipe. Otherwise
 * the manifest will not be found.
 *
 * As this pipe needs to know about all the textures in the texture files most of the work is done
 * in the finish method.
 *
 * Kind of like applying a patch at the end of the manifest process.
 *
 * @param _options
 * @returns
 */
export function texturePackerManifestMod(
    _options: TexturePackerManifestOptions = {}
): AssetPipe<TexturePackerManifestOptions>
{
    const defaultOptions = {
        output: 'manifest.json',
        ..._options
    };

    return {
        folder: false,
        name: 'texture-packer-manifest',
        defaultOptions,

        async finish(asset: Asset, options, pipeSystem)
        {
            const manifestLocation = options.output;

            const newFileName = path.dirname(manifestLocation) === '.'
                ? path.joinSafe(pipeSystem.outputPath, manifestLocation) : manifestLocation;

            if (!existsSync(newFileName))
            {
                // eslint-disable-next-line max-len
                console.warn(`[Assetpack] Texture Packer Manifest could not find the manifest: ${newFileName}. Please ensure that the 'pixiManifest' output and the 'texturePackerManifest' output are the same.`);

                return;
            }

            const manifest = readJsonSync(newFileName);

            // used to make sure we don't process the same asset twice.
            const duplicateHash: Record<string, boolean> = {};

            const originalJsonAssets = findAssets((asset) =>
                asset.metaData.tps && !asset.transformParent, asset, true);

            originalJsonAssets.forEach((originalJsonAsset) =>
            {
                // if we have already processed this asset then skip it.
                if (duplicateHash[originalJsonAsset.path]) return;

                duplicateHash[originalJsonAsset.path] = true;

                // now get all the final assets that were created for this sprite sheet.
                // this will include all the variations of the textures and the jsons.
                const finalJsonAssets = originalJsonAsset.getFinalTransformedChildren();

                // next find the manifestAsset data that was added by the manifest - this is the data that
                // we need to remove and replace with the new data for each PAGE of the sprite sheet.
                const jsonManifestPath = path.relative(pipeSystem.outputPath, finalJsonAssets[0].path);

                const { manifestAsset, bundle } = findManifestAsset(manifest, jsonManifestPath);

                // now we need to get the pages of the sprite sheet and update the manifest with the new pages.
                getTexturePackedAssets(finalJsonAssets).forEach((pages, pageIndex) =>
                {
                    bundle.assets.push({
                        // use the same alias as the original asset but add the page index to it.
                        // we don't control what the alias is so we use whats here.
                        alias: manifestAsset.alias.map((alias: string[]) =>
                            `${alias}-${pageIndex}`),
                        src: pages
                            .map((finalAsset) => path.relative(pipeSystem.outputPath, finalAsset.path))
                            .sort((a, b) => b.localeCompare(a)),
                        data:  manifestAsset.data
                    });
                });

                // to wrap up remove the original manifest asset from the bundle.
                bundle.assets.splice(bundle.assets.indexOf(manifestAsset), 1);
            });

            // write the new manifest.
            writeJSONSync(newFileName, manifest, { spaces: 2 });

            return;
        }
    };
}

function getTexturePackedAssets(assets: Asset[])
{
    // first get the jsons..
    const jsonAssets = assets.filter((asset) => asset.extension === '.json');

    const groupAssets: Asset[][] = [];

    for (let i = 0; i < jsonAssets.length; i++)
    {
        const jsonAsset = jsonAssets[i];

        groupAssets[jsonAsset.allMetaData.page] ??= [];

        groupAssets[jsonAsset.allMetaData.page].push(jsonAsset);
    }

    return groupAssets;
}

function findManifestAsset(manifest: any, assetPath: string): {bundle: any, manifestAsset: any}
{
    for (let i = 0; i < manifest.bundles.length; i++)
    {
        const bundle = manifest.bundles[i];
        const assets = bundle.assets;

        const manifestAsset = assets.find((asset: {src: string[]}) =>

            asset.src.includes(assetPath)
        );

        if (manifestAsset)
        {
            return { bundle, manifestAsset };
        }
    }

    return { bundle: null, manifestAsset: null };
}
